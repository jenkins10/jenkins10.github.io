<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Optical Navigation Pipeline Demo — Stephen Jenkins</title>
  <meta name="description" content="Interactive demo of DART-like optical navigation image processing pipeline: starfield detection, centroiding, and target discrimination.">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../css/style.css">
  <style>
    .pipeline-steps {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 2rem;
      overflow-x: auto;
      padding-bottom: 0.5rem;
    }
    .pipeline-step {
      padding: 0.6rem 1.1rem;
      border-radius: 6px;
      font-size: 0.82rem;
      font-weight: 600;
      white-space: nowrap;
      cursor: pointer;
      border: 1.5px solid var(--border);
      background: var(--white);
      color: var(--slate);
      transition: all var(--transition);
      flex-shrink: 0;
    }
    .pipeline-step:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    .pipeline-step.active {
      background: var(--accent);
      color: var(--white);
      border-color: var(--accent);
    }
    .pipeline-step.completed {
      background: var(--accent-light);
      color: var(--accent);
      border-color: var(--accent);
    }

    .demo-canvas-container {
      aspect-ratio: 16 / 9;
      background: var(--navy);
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      margin-bottom: 2rem;
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    }
    .demo-canvas-container canvas {
      width: 100%;
      height: 100%;
      display: block;
    }

    .controls-section {
      background: var(--light);
      border-radius: 12px;
      padding: 2rem;
      margin-bottom: 2rem;
      border: 1px solid var(--border);
    }
    .controls-section h3 {
      font-size: 0.9rem;
      font-weight: 700;
      color: var(--navy);
      margin-bottom: 1.5rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .slider-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 1.5rem;
    }

    .slider-control {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }
    .slider-label {
      display: flex;
      justify-content: space-between;
      font-size: 0.8rem;
      color: var(--slate);
    }
    .slider-label span:last-child {
      font-family: var(--mono);
      font-weight: 600;
      color: var(--navy);
    }
    input[type="range"] {
      width: 100%;
      height: 5px;
      border-radius: 3px;
      background: var(--border);
      outline: none;
      -webkit-appearance: none;
      cursor: pointer;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
      transition: box-shadow 0.2s;
    }
    input[type="range"]::-webkit-slider-thumb:hover {
      box-shadow: 0 0 0 6px rgba(44, 111, 187, 0.15);
    }
    input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      cursor: pointer;
    }

    .button-group {
      display: flex;
      gap: 1rem;
      flex-wrap: wrap;
      margin-top: 1.5rem;
    }

    .telemetry-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
      gap: 1rem;
      background: var(--navy);
      border-radius: 12px;
      padding: 1.5rem;
      margin-bottom: 2rem;
    }
    .telemetry-item {
      text-align: center;
    }
    .telemetry-value {
      font-family: var(--mono);
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 0.3rem;
    }
    .telemetry-label {
      font-size: 0.7rem;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }

    .info-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
      gap: 1.5rem;
    }
    .info-card {
      padding: 2rem;
      background: var(--white);
      border: 1px solid var(--border);
      border-radius: 12px;
      transition: all var(--transition);
    }
    .info-card:hover {
      border-color: var(--accent);
      box-shadow: 0 8px 24px rgba(0,0,0,0.06);
    }
    .info-card h3 {
      font-size: 1.05rem;
      font-weight: 700;
      color: var(--navy);
      margin-bottom: 0.75rem;
    }
    .info-card p {
      font-size: 0.9rem;
      color: var(--slate);
      line-height: 1.6;
      margin-bottom: 0.75rem;
    }
    .info-card p:last-child {
      margin-bottom: 0;
    }

    .equation-block {
      font-family: var(--mono);
      font-size: 0.85rem;
      background: var(--light);
      padding: 1rem 1.25rem;
      border-radius: 8px;
      border-left: 3px solid var(--accent);
      overflow-x: auto;
      margin: 1rem 0;
      color: var(--navy);
      line-height: 1.5;
    }

    .step-description {
      font-size: 0.9rem;
      color: var(--slate);
      padding: 1rem 1.5rem;
      background: var(--light);
      border-radius: 8px;
      margin-bottom: 1.5rem;
      border-left: 3px solid var(--accent);
    }

    .toggle-switch {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    .toggle-switch label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: var(--slate);
      cursor: pointer;
    }
    .toggle-switch input[type="checkbox"] {
      width: 16px;
      height: 16px;
      cursor: pointer;
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="nav" id="nav">
    <div class="nav-inner">
      <a href="../index.html" class="nav-logo">SJ<span>.</span></a>
      <ul class="nav-links" id="navLinks">
        <li><a href="../index.html#about">About</a></li>
        <li><a href="../index.html#projects">Projects</a></li>
        <li><a href="../resume.html">Resume</a></li>
        <li><a href="../index.html#contact">Contact</a></li>
      </ul>
      <button class="nav-toggle" id="navToggle" aria-label="Toggle menu">
        <span></span><span></span><span></span>
      </button>
    </div>
  </nav>

  <!-- Hero -->
  <section class="demo-hero">
    <div class="demo-hero-inner">
      <a href="../index.html#projects" class="back-link">← Back to Projects</a>
      <h1>Optical Navigation Pipeline</h1>
      <p>
        Explore the image processing pipeline that guided NASA's DART spacecraft to impact asteroid Dimorphos.
        This interactive demo simulates the SMART Nav optical navigation system: detecting celestial bodies
        in starfield imagery, computing sub-pixel centroids, and discriminating target from primary body.
      </p>
    </div>
  </section>

  <!-- Main Demo Section -->
  <section class="demo-section">
    <div class="demo-inner">

      <!-- Pipeline Stage Selector -->
      <div class="pipeline-steps" id="pipelineSteps"></div>

      <!-- Canvas -->
      <div class="demo-canvas-container">
        <canvas id="navCanvas"></canvas>
      </div>

      <!-- Step Description -->
      <div class="step-description" id="stepDescription"></div>

      <!-- Telemetry -->
      <div class="telemetry-grid" id="telemetryGrid"></div>

      <!-- Controls -->
      <div class="controls-section">
        <h3>Interactive Controls</h3>

        <div class="slider-row">
          <div class="slider-control">
            <label class="slider-label">
              <span>Approach Distance</span>
              <span id="distanceValue">80%</span>
            </label>
            <input type="range" id="distanceSlider" min="10" max="100" value="80" step="1">
          </div>

          <div class="slider-control">
            <label class="slider-label">
              <span>Sensor Noise Level</span>
              <span id="noiseValue">0.15</span>
            </label>
            <input type="range" id="noiseSlider" min="0" max="0.5" value="0.15" step="0.05">
          </div>

          <div class="slider-control">
            <label class="slider-label">
              <span>Detection Threshold</span>
              <span id="thresholdValue">0.35</span>
            </label>
            <input type="range" id="thresholdSlider" min="0.1" max="0.8" value="0.35" step="0.05">
          </div>
        </div>

        <div class="button-group">
          <button class="demo-btn" id="autoPlayBtn">▶ Auto-Play</button>
          <button class="demo-btn" id="pauseBtn">⏸ Pause</button>
          <button class="demo-btn" id="resetBtn">↻ Reset</button>
          <div class="toggle-switch">
            <input type="checkbox" id="autoAdvanceToggle" checked>
            <label for="autoAdvanceToggle">Auto-advance stages</label>
          </div>
        </div>
      </div>

    </div>
  </section>

  <!-- Educational Content -->
  <section class="demo-section" style="background: var(--light);">
    <div class="demo-inner">
      <h2 class="section-title" style="margin-bottom: 2rem;">Pipeline Overview</h2>

      <div class="info-cards">
        <div class="info-card">
          <h3>Raw Image Acquisition</h3>
          <p>
            The spacecraft's camera captures imagery of the target region as it approaches.
            The starfield provides context; Didymos (primary, larger) and Dimorphos (secondary, smaller) appear as bright regions against the star background.
          </p>
          <p style="font-size: 0.8rem; color: var(--muted); margin-top: 1rem;">
            <strong>Stage 1:</strong> Input sensor data with Gaussian noise characteristic of space-qualified imaging systems.
          </p>
        </div>

        <div class="info-card">
          <h3>Background Subtraction &amp; Preprocessing</h3>
          <p>
            Removes the static starfield background using local averaging and morphological operations.
            This isolation improves signal-to-noise ratio and enhances the detectability of moving or extended targets.
          </p>
          <p style="font-size: 0.8rem; color: var(--muted); margin-top: 1rem;">
            <strong>Stage 2:</strong> Enhanced image with astronomical background removed.
          </p>
        </div>

        <div class="info-card">
          <h3>Thresholding &amp; Binarization</h3>
          <p>
            Applies adaptive thresholding to create a binary mask above a configurable detection threshold.
            Only pixels with sufficient signal relative to noise are marked as target pixels.
          </p>
          <p style="font-size: 0.8rem; color: var(--muted); margin-top: 1rem;">
            <strong>Stage 3:</strong> Binary detection mask ready for connected component analysis.
          </p>
        </div>

        <div class="info-card">
          <h3>Blob Detection &amp; Connected Components</h3>
          <p>
            Identifies connected regions (blobs) in the binary image. For each blob, computes bounding box,
            area, and moments for centroiding. Uses recursive flood-fill or union-find algorithms.
          </p>
          <p style="font-size: 0.8rem; color: var(--muted); margin-top: 1rem;">
            <strong>Stage 4:</strong> Isolated objects with individual bounding boxes and properties.
          </p>
        </div>

        <div class="info-card">
          <h3>Sub-Pixel Centroiding</h3>
          <p>
            Computes weighted centroid of each blob using intensity-weighted moments. Achieves sub-pixel accuracy
            by integrating over the extended blob area, critical for precise targeting.
          </p>
          <p style="font-size: 0.8rem; color: var(--muted); margin-top: 1rem;">
            <strong>Stage 5:</strong> Precise (x, y) centroid coordinates for each detected body.
          </p>
        </div>

        <div class="info-card">
          <h3>Target Discrimination &amp; Classification</h3>
          <p>
            Classifies detected blobs to identify the primary body (Didymos) and target (Dimorphos).
            Uses blob size, relative position, and angular separation to discriminate the smaller body
            and compute final targeting vectors.
          </p>
          <p style="font-size: 0.8rem; color: var(--muted); margin-top: 1rem;">
            <strong>Stage 6:</strong> Final targeting data ready for autonomous guidance commands.
          </p>
        </div>
      </div>
    </div>
  </section>

  <!-- Centroiding Algorithm -->
  <section class="demo-section">
    <div class="demo-inner">
      <h2 class="section-title">Centroiding Algorithm</h2>
      <p class="section-desc">
        The weighted centroid computation is fundamental to optical navigation accuracy. By integrating
        over the entire blob area (not just the peak), we achieve sub-pixel precision necessary for
        autonomous spacecraft targeting.
      </p>

      <div class="info-cards">
        <div class="info-card">
          <h3>Mathematical Foundation</h3>
          <p>
            The intensity-weighted centroid (first moment) is computed as:
          </p>
          <div class="equation-block">
cx = Σ(x × I(x,y)) / Σ(I(x,y))
cy = Σ(y × I(x,y)) / Σ(I(x,y))
          </div>
          <p>
            Where I(x,y) is the image intensity at pixel (x,y), and the sum is over all detected pixels.
            This method provides superior accuracy compared to peak-finding or center-of-mass on binary masks.
          </p>
        </div>

        <div class="info-card">
          <h3>Practical Advantages</h3>
          <p>
            <strong>Sub-pixel Accuracy:</strong> Intensity weighting allows precision better than pixel resolution.<br><br>
            <strong>Robustness to Noise:</strong> Extended blob integration averages out random noise variations.<br><br>
            <strong>Computational Efficiency:</strong> Single-pass summation with O(n) complexity.<br><br>
            <strong>Spline Refinement:</strong> Optional Gaussian PSF fitting further improves accuracy to &lt;0.1 pixels.
          </p>
        </div>

        <div class="info-card">
          <h3>DART Implementation</h3>
          <p>
            SMART Nav (Small-body Maneuvering Autonomous Real-time Navigation) integrated this centroiding
            algorithm in real-time flight code. The spacecraft computed centroids onboard at 2 Hz, enabling
            autonomous final approach corrections within 20 minutes of impact.
          </p>
          <p style="margin-top: 1rem; font-size: 0.9rem;">
            The target discrimination refinement identified Dimorphos (≈160 m) as a separate body from
            Didymos (≈780 m), adjusting steering vectors to hit the smaller moonlet with meter-scale accuracy.
          </p>
        </div>
      </div>
    </div>
  </section>

  <!-- DART Connection -->
  <section class="demo-section" style="background: var(--light);">
    <div class="demo-inner">
      <h2 class="section-title">From Simulation to Flight</h2>

      <div class="info-cards">
        <div class="info-card">
          <h3>DART Mission Context</h3>
          <p>
            NASA's Double Asteroid Redirection Test (DART) impacted asteroid Dimorphos on September 26, 2022.
            The mission demonstrated planetary defense by measuring the momentum transfer from kinetic impact.
          </p>
          <p>
            <strong>Challenge:</strong> Dimorphos is only ~160 meters across, orbiting at a distance of 1,200 km from Earth.
            Optical navigation had to discriminate it from its primary, Didymos (~780 m), and compute final impact vectors
            with unprecedented autonomy during the final 20 minutes.
          </p>
        </div>

        <div class="info-card">
          <h3>SMART Nav System Architecture</h3>
          <p>
            The onboard autonomous navigation function (Autonomous Onboard Navigation and Image Processing subsystem)
            processed imagery at 2 Hz during final approach. Centroid measurements were fused with spacecraft state estimates
            in an extended Kalman filter to refine trajectory, enabling steering corrections as late as 2 seconds pre-impact.
          </p>
          <p style="margin-top: 1rem;">
            This demo captures the core image processing pipeline that ran in real-time on DART's modest flight computer.
          </p>
        </div>

        <div class="info-card">
          <h3>Mission Success &amp; Impact</h3>
          <p>
            DART successfully impacted Dimorphos, changing its orbital period by 73 minutes—far exceeding the 73-second
            minimum success threshold. This breakthrough validated kinetic impactor technology for planetary defense.
          </p>
          <p style="margin-top: 1rem;">
            <strong>Optical Navigation Role:</strong> Precision guidance and autonomous targeting were critical to mission success.
            The algorithms demonstrated here made impact possible.
          </p>
        </div>
      </div>

      <p style="text-align: center; color: var(--muted); margin-top: 3rem; font-size: 0.9rem;">
        © 2024 Stephen Jenkins. This demo is for educational and portfolio purposes, demonstrating simplified
        versions of flight algorithms. Actual SMART Nav implementation involved additional subsystems, redundancy,
        and real-time constraints not depicted here.
      </p>
    </div>
  </section>

  <script>
    // ============================================
    // Optical Navigation Pipeline Demo
    // ============================================

    class OpticalNavDemo {
      constructor() {
        this.canvas = document.getElementById('navCanvas');
        this.ctx = this.canvas.getContext('2d');

        // Set canvas size
        this.resizeCanvas();
        window.addEventListener('resize', () => this.resizeCanvas());

        // State
        this.currentStep = 0;
        this.isPlaying = false;
        this.autoAdvance = true;
        this.time = 0;
        this.approachDistance = 0.8;
        this.noiseLevelVal = 0.15;
        this.detectionThreshold = 0.35;

        // Pipeline stages
        this.stages = [
          { name: 'Raw Image', description: 'Input sensor data capturing the asteroid system against the starfield background.' },
          { name: 'Background Subtraction', description: 'Astronomical background removed via local averaging. Star field isolation improved.' },
          { name: 'Thresholding', description: 'Binary detection mask: pixels above detection threshold marked as candidate target.' },
          { name: 'Blob Detection', description: 'Connected component analysis identifies individual bodies with bounding boxes.' },
          { name: 'Centroiding', description: 'Intensity-weighted moments computed for sub-pixel centroid accuracy.' },
          { name: 'Target Discrimination', description: 'Primary (Didymos) classified vs. target (Dimorphos). Separation vectors computed.' }
        ];

        // Generated imagery
        this.starfield = null;
        this.bodies = null;
        this.generateAssets();

        // Setup UI
        this.setupControls();
        this.setupPipeline();
        this.setupTelemetry();

        // Animation loop
        this.animationFrame = null;
        this.animate();
      }

      resizeCanvas() {
        const rect = this.canvas.parentElement.getBoundingClientRect();
        this.canvas.width = rect.width;
        this.canvas.height = rect.height;
      }

      generateAssets() {
        // Generate starfield once
        this.starfield = this.generateStarfield(this.canvas.width, this.canvas.height);

        // Define celestial bodies (in relative units)
        this.bodies = [
          {
            name: 'Didymos (Primary)',
            baseRadius: 0.08,
            brightness: 0.9,
            x: 0.55,
            y: 0.45,
            color: [200, 180, 150]
          },
          {
            name: 'Dimorphos (Target)',
            baseRadius: 0.03,
            brightness: 0.7,
            x: 0.42,
            y: 0.52,
            color: [180, 160, 140]
          }
        ];
      }

      generateStarfield(width, height) {
        const imageData = this.ctx.createImageData(width, height);
        const data = imageData.data;

        // Dark background
        for (let i = 0; i < data.length; i += 4) {
          data[i] = 8;     // R
          data[i+1] = 12;  // G
          data[i+2] = 20;  // B
          data[i+3] = 255; // A
        }

        // Add stars with realistic distribution
        const starCount = Math.floor(width * height / 500);
        for (let i = 0; i < starCount; i++) {
          const x = Math.floor(Math.random() * width);
          const y = Math.floor(Math.random() * height);

          // Brightness follows power law (more dim stars than bright)
          const brightness = Math.pow(Math.random(), 1.5);
          const intensity = Math.floor(30 + brightness * 220);

          const idx = (y * width + x) * 4;
          data[idx] = intensity;
          data[idx+1] = intensity;
          data[idx+2] = intensity + 10;
          data[idx+3] = 255;

          // Star diffraction spikes (simple cross pattern)
          if (brightness > 0.7) {
            this.addStarSpikes(data, width, height, x, y, intensity * 0.3);
          }
        }

        return imageData;
      }

      addStarSpikes(data, width, height, cx, cy, intensity) {
        const len = 5;
        for (let d = 1; d < len; d++) {
          // Horizontal
          if (cx + d < width) {
            const idx = (cy * width + cx + d) * 4;
            data[idx] = Math.min(255, data[idx] + intensity / d);
          }
          if (cx - d >= 0) {
            const idx = (cy * width + cx - d) * 4;
            data[idx] = Math.min(255, data[idx] + intensity / d);
          }
          // Vertical
          if (cy + d < height) {
            const idx = ((cy + d) * width + cx) * 4;
            data[idx+2] = Math.min(255, data[idx+2] + intensity / d);
          }
          if (cy - d >= 0) {
            const idx = ((cy - d) * width + cx) * 4;
            data[idx+2] = Math.min(255, data[idx+2] + intensity / d);
          }
        }
      }

      generateRawImage() {
        const imgData = this.ctx.createImageData(this.canvas.width, this.canvas.height);
        const data = imgData.data;

        // Start with starfield
        const starData = this.starfield.data;
        for (let i = 0; i < starData.length; i++) {
          data[i] = starData[i];
        }

        // Add celestial bodies
        const w = this.canvas.width;
        const h = this.canvas.height;

        for (const body of this.bodies) {
          const radius = body.baseRadius * Math.min(w, h) * (1 + this.approachDistance);
          const cx = body.x * w;
          const cy = body.y * h;

          // Gaussian blob
          for (let y = Math.max(0, Math.floor(cy - radius * 2)); y < Math.min(h, Math.floor(cy + radius * 2)); y++) {
            for (let x = Math.max(0, Math.floor(cx - radius * 2)); x < Math.min(w, Math.floor(cx + radius * 2)); x++) {
              const dx = x - cx;
              const dy = y - cy;
              const dist2 = dx * dx + dy * dy;
              const sigma2 = radius * radius / 4;
              const gaussian = Math.exp(-dist2 / (2 * sigma2));
              const intensity = body.brightness * gaussian * 255;

              const idx = (y * w + x) * 4;
              data[idx] = Math.min(255, data[idx] + intensity * body.color[0] / 255);
              data[idx+1] = Math.min(255, data[idx+1] + intensity * body.color[1] / 255);
              data[idx+2] = Math.min(255, data[idx+2] + intensity * body.color[2] / 255);
            }
          }
        }

        // Add sensor noise
        const noiseStd = this.noiseLevelVal * 255;
        for (let i = 0; i < data.length; i += 4) {
          const noise = (Math.random() - 0.5) * 2 * noiseStd * 2.355; // 2.355 is 2*sqrt(2*ln(2))
          data[i] = Math.max(0, Math.min(255, data[i] + noise));
          data[i+1] = Math.max(0, Math.min(255, data[i+1] + noise));
          data[i+2] = Math.max(0, Math.min(255, data[i+2] + noise));
        }

        return imgData;
      }

      subtractBackground(imgData) {
        const data = imgData.data;
        const w = this.canvas.width;
        const h = this.canvas.height;
        const result = this.ctx.createImageData(w, h);
        const resultData = result.data;

        // Local background estimation (simplified: use median filter)
        const windowSize = 11;
        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            const y0 = Math.max(0, y - windowSize / 2);
            const y1 = Math.min(h, y + windowSize / 2);
            const x0 = Math.max(0, x - windowSize / 2);
            const x1 = Math.min(w, x + windowSize / 2);

            const values = [];
            for (let ky = Math.floor(y0); ky < Math.floor(y1); ky++) {
              for (let kx = Math.floor(x0); kx < Math.floor(x1); kx++) {
                values.push(data[(ky * w + kx) * 4]);
              }
            }
            values.sort((a, b) => a - b);
            const median = values[Math.floor(values.length / 2)];

            const idx = (y * w + x) * 4;
            const val = Math.max(0, data[idx] - median * 0.8);
            resultData[idx] = val;
            resultData[idx+1] = Math.max(0, data[idx+1] - median * 0.8);
            resultData[idx+2] = Math.max(0, data[idx+2] - median * 0.8);
            resultData[idx+3] = 255;
          }
        }

        return result;
      }

      applyThreshold(imgData, threshold) {
        const data = imgData.data;
        const w = this.canvas.width;
        const h = this.canvas.height;
        const result = this.ctx.createImageData(w, h);
        const resultData = result.data;

        const threshValue = threshold * 255;
        for (let i = 0; i < data.length; i += 4) {
          const intensity = data[i];
          const binary = intensity > threshValue ? 255 : 0;
          resultData[i] = binary;
          resultData[i+1] = binary;
          resultData[i+2] = binary;
          resultData[i+3] = 255;
        }

        return result;
      }

      blobDetect(binaryData) {
        const data = binaryData.data;
        const w = this.canvas.width;
        const h = this.canvas.height;
        const visited = new Uint8Array(w * h);
        const blobs = [];

        const floodFill = (startX, startY) => {
          const stack = [[startX, startY]];
          const pixels = [];

          while (stack.length > 0) {
            const [x, y] = stack.pop();
            if (x < 0 || x >= w || y < 0 || y >= h) continue;
            if (visited[y * w + x]) continue;

            const idx = (y * w + x) * 4;
            if (data[idx] < 128) continue; // Not white

            visited[y * w + x] = 1;
            pixels.push([x, y]);

            stack.push([x+1, y], [x-1, y], [x, y+1], [x, y-1]);
          }

          return pixels;
        };

        for (let y = 0; y < h; y++) {
          for (let x = 0; x < w; x++) {
            if (!visited[y * w + x]) {
              const idx = (y * w + x) * 4;
              if (data[idx] > 128) {
                const pixels = floodFill(x, y);
                if (pixels.length > 5) {
                  blobs.push(pixels);
                }
              }
            }
          }
        }

        return blobs;
      }

      computeCentroid(pixels, imgData) {
        const data = imgData.data;
        const w = this.canvas.width;

        let sumX = 0, sumY = 0, sumI = 0;
        let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;

        for (const [x, y] of pixels) {
          const idx = (y * w + x) * 4;
          const intensity = data[idx] / 255; // Normalized intensity
          sumX += x * intensity;
          sumY += y * intensity;
          sumI += intensity;
          minX = Math.min(minX, x);
          maxX = Math.max(maxX, x);
          minY = Math.min(minY, y);
          maxY = Math.max(maxY, y);
        }

        const cx = sumI > 0 ? sumX / sumI : 0;
        const cy = sumI > 0 ? sumY / sumI : 0;

        return {
          x: cx,
          y: cy,
          intensity: sumI / pixels.length,
          radius: Math.max(maxX - minX, maxY - minY) / 2,
          bbox: { minX, maxX, minY, maxY }
        };
      }

      discriminateTarget(blobs, bgSubData, rawData) {
        // Compute centroids for all blobs
        const detections = blobs.map(pixels => {
          const centroid = this.computeCentroid(pixels, bgSubData);
          return { ...centroid, pixels };
        });

        // Sort by size (intensity * area)
        detections.sort((a, b) => (b.intensity * b.radius) - (a.intensity * a.radius));

        // Classify: largest is primary, smaller is target
        const classifications = [];
        for (let i = 0; i < detections.length && i < 2; i++) {
          classifications.push({
            ...detections[i],
            isTarget: i === 1,
            name: i === 0 ? 'Primary (Didymos)' : 'Target (Dimorphos)'
          });
        }

        return classifications;
      }

      computeAngularSeparation(pos1, pos2) {
        const dx = pos2.x - pos1.x;
        const dy = pos2.y - pos1.y;
        const distPixels = Math.sqrt(dx*dx + dy*dy);
        // Rough conversion: assume 0.5 deg FOV per 500 pixels
        return (distPixels / 500) * 0.5 * 3600; // in arcseconds
      }

      computeSNR(centroid) {
        // Rough SNR estimate based on intensity
        return Math.max(3, centroid.intensity * 50);
      }

      computeConfidence(centroid) {
        // Confidence based on intensity and size consistency
        const baseConf = 0.5 + centroid.intensity * 0.4;
        return Math.min(0.99, baseConf);
      }

      render() {
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Generate base image
        const rawImage = this.generateRawImage();

        // Process through pipeline
        let processed = rawImage;
        let binaryData = null;
        let blobs = [];
        let detections = [];

        if (this.currentStep >= 1) {
          processed = this.subtractBackground(rawImage);
        }

        if (this.currentStep >= 2) {
          binaryData = this.applyThreshold(processed, this.detectionThreshold);
          processed = binaryData;
        } else if (this.currentStep >= 1) {
          binaryData = this.applyThreshold(processed, this.detectionThreshold);
        }

        if (this.currentStep >= 3 && binaryData) {
          blobs = this.blobDetect(binaryData);
        }

        if (this.currentStep >= 4 && binaryData) {
          const allDetections = blobs.map(pixels => this.computeCentroid(pixels, binaryData));
          detections = allDetections;
        }

        if (this.currentStep >= 5 && binaryData) {
          detections = this.discriminateTarget(blobs, processed, rawImage);
        }

        // Draw processed image
        this.ctx.putImageData(processed, 0, 0);

        // Draw overlays
        if (this.currentStep >= 3) {
          this.drawBlobBoxes(blobs, binaryData);
        }

        if (this.currentStep >= 4) {
          this.drawCentroids(detections);
        }

        if (this.currentStep >= 5) {
          this.drawTargetMarkers(detections);
        }

        // Store for telemetry
        this.lastDetections = detections;
      }

      drawBlobBoxes(blobs, binaryData) {
        this.ctx.strokeStyle = '#00ff00';
        this.ctx.lineWidth = 2;
        this.ctx.fillStyle = 'rgba(0, 255, 0, 0.1)';

        for (const pixels of blobs) {
          let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
          for (const [x, y] of pixels) {
            minX = Math.min(minX, x);
            maxX = Math.max(maxX, x);
            minY = Math.min(minY, y);
            maxY = Math.max(maxY, y);
          }

          const w = maxX - minX + 1;
          const h = maxY - minY + 1;
          this.ctx.fillRect(minX, minY, w, h);
          this.ctx.strokeRect(minX, minY, w, h);
        }
      }

      drawCentroids(detections) {
        for (const det of detections) {
          // Crosshair
          this.ctx.strokeStyle = '#00ffff';
          this.ctx.lineWidth = 2;

          const size = 15;
          this.ctx.beginPath();
          this.ctx.moveTo(det.x - size, det.y);
          this.ctx.lineTo(det.x + size, det.y);
          this.ctx.stroke();

          this.ctx.beginPath();
          this.ctx.moveTo(det.x, det.y - size);
          this.ctx.lineTo(det.x, det.y + size);
          this.ctx.stroke();

          // Center circle
          this.ctx.strokeStyle = '#00ffff';
          this.ctx.lineWidth = 1.5;
          this.ctx.beginPath();
          this.ctx.arc(det.x, det.y, 5, 0, Math.PI * 2);
          this.ctx.stroke();

          // Label
          this.ctx.fillStyle = '#00ffff';
          this.ctx.font = '11px "JetBrains Mono"';
          this.ctx.fillText(`(${det.x.toFixed(1)}, ${det.y.toFixed(1)})`, det.x + 12, det.y - 8);
        }
      }

      drawTargetMarkers(detections) {
        for (const det of detections) {
          const color = det.isTarget ? '#ff6b35' : '#4ecdc4';
          const label = det.isTarget ? 'TARGET' : 'PRIMARY';

          // Box around target
          this.ctx.strokeStyle = color;
          this.ctx.lineWidth = 3;
          const pad = 20;
          const w = (det.bbox.maxX - det.bbox.minX) + pad * 2;
          const h = (det.bbox.maxY - det.bbox.minY) + pad * 2;
          this.ctx.strokeRect(det.bbox.minX - pad, det.bbox.minY - pad, w, h);

          // Label
          this.ctx.fillStyle = color;
          this.ctx.font = 'bold 12px "Inter"';
          this.ctx.fillText(label, det.bbox.minX - pad + 5, det.bbox.minY - pad - 5);
        }
      }

      setupControls() {
        const distSlider = document.getElementById('distanceSlider');
        const noiseSlider = document.getElementById('noiseSlider');
        const thresholdSlider = document.getElementById('thresholdSlider');
        const autoAdvanceCheckbox = document.getElementById('autoAdvanceToggle');

        distSlider.addEventListener('input', (e) => {
          this.approachDistance = parseFloat(e.target.value) / 100;
          document.getElementById('distanceValue').textContent = e.target.value + '%';
        });

        noiseSlider.addEventListener('input', (e) => {
          this.noiseLevelVal = parseFloat(e.target.value);
          document.getElementById('noiseValue').textContent = this.noiseLevelVal.toFixed(2);
        });

        thresholdSlider.addEventListener('input', (e) => {
          this.detectionThreshold = parseFloat(e.target.value);
          document.getElementById('thresholdValue').textContent = this.detectionThreshold.toFixed(2);
        });

        autoAdvanceCheckbox.addEventListener('change', (e) => {
          this.autoAdvance = e.target.checked;
        });

        document.getElementById('autoPlayBtn').addEventListener('click', () => {
          this.isPlaying = true;
          document.getElementById('autoPlayBtn').classList.add('active');
          document.getElementById('pauseBtn').classList.remove('active');
        });

        document.getElementById('pauseBtn').addEventListener('click', () => {
          this.isPlaying = false;
          document.getElementById('pauseBtn').classList.add('active');
          document.getElementById('autoPlayBtn').classList.remove('active');
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
          this.currentStep = 0;
          this.isPlaying = false;
          this.time = 0;
          document.getElementById('autoPlayBtn').classList.remove('active');
          document.getElementById('pauseBtn').classList.remove('active');
          this.updatePipelineUI();
        });
      }

      setupPipeline() {
        const container = document.getElementById('pipelineSteps');
        this.stages.forEach((stage, idx) => {
          const btn = document.createElement('button');
          btn.className = 'pipeline-step';
          btn.textContent = stage.name;
          btn.addEventListener('click', () => {
            this.currentStep = idx;
            this.isPlaying = false;
            this.updatePipelineUI();
          });
          container.appendChild(btn);
        });
        this.updatePipelineUI();
      }

      updatePipelineUI() {
        const buttons = document.querySelectorAll('.pipeline-step');
        const descEl = document.getElementById('stepDescription');

        buttons.forEach((btn, idx) => {
          btn.classList.remove('active', 'completed');
          if (idx === this.currentStep) {
            btn.classList.add('active');
          } else if (idx < this.currentStep) {
            btn.classList.add('completed');
          }
        });

        descEl.textContent = this.stages[this.currentStep].description;
      }

      setupTelemetry() {
        this.updateTelemetry();
      }

      updateTelemetry() {
        const container = document.getElementById('telemetryGrid');
        container.innerHTML = '';

        if (!this.lastDetections || this.lastDetections.length === 0) {
          const nodata = document.createElement('div');
          nodata.className = 'telemetry-item';
          nodata.style.gridColumn = '1 / -1';
          nodata.style.color = 'rgba(255,255,255,0.5)';
          nodata.textContent = 'Process to Stage 5+ for telemetry data';
          container.appendChild(nodata);
          return;
        }

        // Primary
        if (this.lastDetections[0]) {
          const det = this.lastDetections[0];
          const item = document.createElement('div');
          item.className = 'telemetry-item';
          item.innerHTML = `
            <div class="telemetry-value">${det.x.toFixed(1)}</div>
            <div class="telemetry-label">Primary X (px)</div>
          `;
          container.appendChild(item);

          const item2 = document.createElement('div');
          item2.className = 'telemetry-item';
          item2.innerHTML = `
            <div class="telemetry-value">${det.y.toFixed(1)}</div>
            <div class="telemetry-label">Primary Y (px)</div>
          `;
          container.appendChild(item2);

          const item3 = document.createElement('div');
          item3.className = 'telemetry-item';
          item3.innerHTML = `
            <div class="telemetry-value">${this.computeSNR(det).toFixed(1)}</div>
            <div class="telemetry-label">Primary SNR</div>
          `;
          container.appendChild(item3);
        }

        // Target
        if (this.lastDetections[1]) {
          const det = this.lastDetections[1];
          const item = document.createElement('div');
          item.className = 'telemetry-item';
          item.innerHTML = `
            <div class="telemetry-value">${det.x.toFixed(1)}</div>
            <div class="telemetry-label">Target X (px)</div>
          `;
          container.appendChild(item);

          const item2 = document.createElement('div');
          item2.className = 'telemetry-item';
          item2.innerHTML = `
            <div class="telemetry-value">${det.y.toFixed(1)}</div>
            <div class="telemetry-label">Target Y (px)</div>
          `;
          container.appendChild(item2);

          const item3 = document.createElement('div');
          item3.className = 'telemetry-item';
          item3.innerHTML = `
            <div class="telemetry-value">${this.computeSNR(det).toFixed(1)}</div>
            <div class="telemetry-label">Target SNR</div>
          `;
          container.appendChild(item3);

          // Angular separation
          const sep = this.computeAngularSeparation(this.lastDetections[0], det);
          const item4 = document.createElement('div');
          item4.className = 'telemetry-item';
          item4.innerHTML = `
            <div class="telemetry-value">${sep.toFixed(1)}</div>
            <div class="telemetry-label">Angular Sep (″)</div>
          `;
          container.appendChild(item4);

          const conf = this.computeConfidence(det);
          const item5 = document.createElement('div');
          item5.className = 'telemetry-item';
          item5.innerHTML = `
            <div class="telemetry-value">${(conf * 100).toFixed(0)}%</div>
            <div class="telemetry-label">Conf. Score</div>
          `;
          container.appendChild(item5);
        }
      }

      animate = () => {
        this.render();
        this.updateTelemetry();

        if (this.isPlaying) {
          this.time += 0.016; // ~60fps

          // Auto-advance through stages
          if (this.autoAdvance && this.time > 2) {
            if (this.currentStep < this.stages.length - 1) {
              this.currentStep++;
              this.updatePipelineUI();
            } else {
              this.isPlaying = false;
              document.getElementById('autoPlayBtn').classList.remove('active');
            }
            this.time = 0;
          }
        }

        this.animationFrame = requestAnimationFrame(this.animate);
      };
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
      new OpticalNavDemo();
    });

    // Navigation scroll effect
    const nav = document.getElementById('nav');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 10) {
        nav.classList.add('scrolled');
      } else {
        nav.classList.remove('scrolled');
      }
    });

    // Mobile menu toggle
    const navToggle = document.getElementById('navToggle');
    const navLinks = document.getElementById('navLinks');
    navToggle.addEventListener('click', () => {
      navLinks.classList.toggle('open');
    });
  </script>

</body>
</html>
